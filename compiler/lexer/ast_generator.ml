(* ast.mll - Generator script for AST's .mli and .ml files *)

let generate_mli () =
  let oc = open_out "ast.mli" in
  output_string oc "(* ast.mli - Interface for the Ast module *)\n\n";
  output_string oc "type expr =\n";
  output_string oc "  | Int of int\n";
  output_string oc "  | Bool of bool\n";
  output_string oc "  | Var of string\n";
  output_string oc "  | BinOp of string * expr * expr\n";
  output_string oc "  | UnOp of string * expr\n";
  output_string oc "  | FunctionCall of string * expr list\n";
  output_string oc "  | Assign of string * expr\n";
  output_string oc "  | ArrayLiteral of expr list\n";
  output_string oc "  | StructFieldAccess of string * string\n";
  output_string oc "  | FString of string * expr list\n\n";
  output_string oc "type stmt =\n";
  output_string oc "  | Expr of expr\n";
  output_string oc "  | FunctionDef of string * (string * string) list * stmt list\n";
  output_string oc "  | StructDef of string * (string * expr) list\n";
  output_string oc "  | If of expr * stmt list\n";
  output_string oc "  | Else of stmt list\n";
  output_string oc "  | ElseIf of expr * stmt list\n";
  output_string oc "  | While of expr * stmt list\n";
  output_string oc "  | For of string * expr * stmt list\n";
  output_string oc "  | Return of expr\n";
  output_string oc "  | Import of string\n";
  output_string oc "  | As of string\n";
  output_string oc "  | From of string\n";
  output_string oc "  | Pass\n";
  output_string oc "  | Break\n";
  output_string oc "  | Continue\n";
  output_string oc "  | Read\n";
  output_string oc "  | Write of expr\n";
  output_string oc "  | AnnotatedStmt of string * stmt\n\n";
  output_string oc "type program = stmt list\n\n";
  output_string oc "type position = { line: int; column: int }\n\n";
  output_string oc "type 'a annotated = { node: 'a; pos: position }\n\n";
  output_string oc "val expr_to_string : expr -> string\n";
  output_string oc "val stmt_to_string : stmt -> string\n";
  output_string oc "val walk_expr : (expr -> expr) -> expr -> expr\n";
  output_string oc "val walk_stmt : (stmt -> stmt) -> stmt -> stmt\n";
  output_string oc "val annotate_expr : ?debug:bool -> expr -> position -> expr annotated\n";
  output_string oc "val annotate_stmt : ?debug:bool -> stmt -> position -> stmt annotated\n";
  output_string oc "type scope_info = {\n";
  output_string oc "  mutable vars: (string * expr) list;\n";
  output_string oc "}\n";
  output_string oc "val create_scope : unit -> scope_info\n";
  output_string oc "val add_variable_to_scope : scope_info -> string -> expr -> unit\n";
  output_string oc "val find_variable_in_scope : scope_info -> string -> expr option\n";
  close_out oc

let generate_ml () =
  let oc = open_out "ast.ml" in
  output_string oc "(* ast.ml - Implementation for the Ast module *)\n\n";
  output_string oc "open Almostashar\n\n";
  output_string oc "type expr =\n";
  output_string oc "  | Int of int\n";
  output_string oc "  | Bool of bool\n";
  output_string oc "  | Var of string\n";
  output_string oc "  | BinOp of string * expr * expr\n";
  output_string oc "  | UnOp of string * expr\n";
  output_string oc "  | FunctionCall of string * expr list\n";
  output_string oc "  | Assign of string * expr\n";
  output_string oc "  | ArrayLiteral of expr list\n";
  output_string oc "  | StructFieldAccess of string * string\n";
  output_string oc "  | FString of string * expr list\n\n";
  output_string oc "type stmt =\n";
  output_string oc "  | Expr of expr\n";
  output_string oc "  | FunctionDef of string * (string * string) list * stmt list\n";
  output_string oc "  | StructDef of string * (string * expr) list\n";
  output_string oc "  | If of expr * stmt list\n";
  output_string oc "  | Else of stmt list\n";
  output_string oc "  | ElseIf of expr * stmt list\n";
  output_string oc "  | While of expr * stmt list\n";
  output_string oc "  | For of string * expr * stmt list\n";
  output_string oc "  | Return of expr\n";
  output_string oc "  | Import of string\n";
  output_string oc "  | As of string\n";
  output_string oc "  | From of string\n";
  output_string oc "  | Pass\n";
  output_string oc "  | Break\n";
  output_string oc "  | Continue\n";
  output_string oc "  | Read\n";
  output_string oc "  | Write of expr\n";
  output_string oc "  | AnnotatedStmt of string * stmt\n\n";
  output_string oc "type program = stmt list\n\n";
  output_string oc "type position = { line: int; column: int }\n\n";
  output_string oc "type 'a annotated = { node: 'a; pos: position }\n\n";
  output_string oc "let rec expr_to_string = function\n";
  output_string oc "  | Int n -> string_of_int n\n";
  output_string oc "  | Bool b -> string_of_bool b\n";
  output_string oc "  | Var v -> v\n";
  output_string oc "  | BinOp (op, e1, e2) -> \"(\" ^ expr_to_string e1 ^ \" \" ^ op ^ \" \" ^ expr_to_string e2 ^ \")\"\n";
  output_string oc "  | UnOp (op, e) -> op ^ expr_to_string e\n";
  output_string oc "  | FunctionCall (f, args) -> \n";
  output_string oc "    f ^ \"(\" ^ String.concat \", \" (List.map expr_to_string args) ^ \")\"\n";
  output_string oc "  | Assign (v, e) -> v ^ \" = \" ^ expr_to_string e\n";
  output_string oc "  | ArrayLiteral el -> \"[\" ^ String.concat \", \" (List.map expr_to_string el) ^ \"]\"\n";
  output_string oc "  | StructFieldAccess (s, field) -> s ^ \".\" ^ field\n";
  output_string oc "  | FString (fmt, exprs) -> \"f\\\"\" ^ fmt ^ \"\\\"\" ^ \" {\" ^ String.concat \", \" (List.map expr_to_string exprs) ^ \"}\"\n\n";
  output_string oc "let rec stmt_to_string = function\n";
  output_string oc "  | Expr e -> expr_to_string e\n";
  output_string oc "  | FunctionDef (name, params, body) -> \n";
  output_string oc "    \"def \" ^ name ^ \"(\" ^ String.concat \", \" (List.map (fun (p, t) -> p ^ \" -> \" ^ t) params) ^ \") { \" ^ stmts_to_string body ^ \" }\"\n";
  output_string oc "  | StructDef (name, fields) ->\n";
  output_string oc "    \"public struct \" ^ name ^ \" = { \" ^ String.concat \"; \" (List.map (fun (field, value) -> field ^ \" -> \" ^ expr_to_string value) fields) ^ \" }\"\n";
  output_string oc "  | If (cond, body) -> \"if (\" ^ expr_to_string cond ^ \") { \" ^ stmts_to_string body ^ \" }\"\n";
  output_string oc "  | Else body -> \"else { \" ^ stmts_to_string body ^ \" }\"\n";
  output_string oc "  | ElseIf (cond, body) -> \"else if (\" ^ expr_to_string cond ^ \") { \" ^ stmts_to_string body ^ \" }\"\n";
  output_string oc "  | While (cond, body) -> \"while (\" ^ expr_to_string cond ^ \") { \" ^ stmts_to_string body ^ \" }\"\n";
  output_string oc "  | For (var, expr, body) -> \"for (\" ^ var ^ \" in \" ^ expr_to_string expr ^ \") { \" ^ stmts_to_string body ^ \" }\"\n";
  output_string oc "  | Return expr -> \"return \" ^ expr_to_string expr\n";
  output_string oc "  | Import name -> \"import \" ^ name\n";
  output_string oc "  | As name -> \"as \" ^ name\n";
  output_string oc "  | From name -> \"from \" ^ name\n";
  output_string oc "  | Pass -> \"pass\"\n";
  output_string oc "  | Break -> \"break\"\n";
  output_string oc "  | Continue -> \"continue\"\n";
  output_string oc "  | Read -> \"read\"\n";
  output_string oc "  | Write expr -> \"write \" ^ expr_to_string expr\n";
  output_string oc "  | AnnotatedStmt (annotation, stmt) -> \"@\" ^ annotation ^ \" \" ^ stmt_to_string stmt\n\n";
  output_string oc "and stmts_to_string stmts = String.concat \"; \" (List.map stmt_to_string stmts)\n\n";
  output_string oc "let rec walk_expr f expr =\n";
  output_string oc "  conditional_debug_expr expr;\n";
  output_string oc "  match expr with\n";
  output_string oc "  | Int _ | Bool _ | Var _ -> f expr\n";
  output_string oc "  | BinOp (op, e1, e2) -> f (BinOp (op, walk_expr f e1, walk_expr f e2))\n";
  output_string oc "  | UnOp (op, e) -> f (UnOp (op, walk_expr f e))\n";
  output_string oc "  | FunctionCall (name, args) -> f (FunctionCall (name, List.map (walk_expr f) args))\n";
  output_string oc "  | Assign (v, e) -> f (Assign (v, walk_expr f e))\n";
  output_string oc "  | ArrayLiteral el -> f (ArrayLiteral (List.map (walk_expr f) el))\n";
  output_string oc "  | StructFieldAccess (s, field) -> f (StructFieldAccess (s, field))\n";
  output_string oc "  | FString (fmt, exprs) -> f (FString (fmt, List.map (walk_expr f) exprs))\n\n";
  output_string oc "let rec walk_stmt f stmt =\n";
  output_string oc "  conditional_debug_stmt stmt;\n";
  output_string oc "  let walk_stmts stmts = List.map (walk_stmt f) stmts in\n";
  output_string oc "  match stmt with\n";
  output_string oc "  | Expr e -> Expr (walk_expr (fun e -> match f (Expr e) with Expr e' -> e' | _ -> e) e)\n";
  output_string oc "  | FunctionDef (name, params, body) -> f (FunctionDef (name, params, walk_stmts body))\n";
  output_string oc "  | StructDef (name, fields) ->\n";
  output_string oc "    f (StructDef (name, List.map (fun (field, value) -> (field, walk_expr f value)) fields))\n";
  output_string oc "  | If (cond, body) -> f (If (walk_expr (fun e -> match f (Expr e) with Expr e' -> e' | _ -> e) cond, walk_stmts body))\n";
  output_string oc "  | Else body -> f (Else (walk_stmts body))\n";
  output_string oc "  | ElseIf (cond, body) -> f (ElseIf (walk_expr (fun e -> match f (Expr e) with Expr e' -> e' | _ -> e) cond, walk_stmts body))\n";
  output_string oc "  | While (cond, body) -> f (While (walk_expr (fun e -> match f (Expr e) with Expr e' -> e' | _ -> e) cond, walk_stmts body))\n";
  output_string oc "  | For (var, expr, body) -> f (For (var, walk_expr (fun e -> match f (Expr e) with Expr e' -> e' | _ -> e) expr, walk_stmts body))\n";
  output_string oc "  | Return expr -> f (Return (walk_expr (fun e -> match f (Expr e) with Expr e' -> e' | _ -> e) expr))\n";
  output_string oc "  | Import _ | As _ | From _ | Pass | Break | Continue | Read -> f stmt\n";
  output_string oc "  | Write expr -> f (Write (walk_expr (fun e -> match f (Expr e) with Expr e' -> e' | _ -> e) expr))\n";
  output_string oc "  | AnnotatedStmt (annotation, stmt) -> f (AnnotatedStmt (annotation, walk_stmt f stmt))\n\n";
  output_string oc "let print_expr (expression: expr) = print_endline (expr_to_string expression)\n";
  output_string oc "let print_stmt (statement: stmt) = print_endline (stmt_to_string statement)\n\n";
  output_string oc "let annotate_expr ?(debug=false) (expression: expr) (pos: position) =\n";
  output_string oc "  let annotated = { node = expression; pos } in\n";
  output_string oc "  if debug then conditional_debug_annotated_expr expression pos;\n";
  output_string oc "  annotated\n\n";
  output_string oc "let annotate_stmt ?(debug=false) (statement: stmt) (pos: position) =\n";
  output_string oc "  let annotated = { node = statement; pos } in\n";
  output_string oc "  if debug then conditional_debug_annotated_stmt statement pos;\n";
  output_string oc "  annotated\n\n";
  output_string oc "type scope_info = {\n";
  output_string oc "  mutable vars: (string * expr) list;\n";
  output_string oc "}\n\n";
  output_string oc "let create_scope () = { vars = [] }\n\n";
  output_string oc "let add_variable_to_scope (scope: scope_info) (name: string) (value: expr) = \n";
  output_string oc "  scope.vars <- (name, value) :: scope.vars\n\n";
  output_string oc "let find_variable_in_scope (scope: scope_info) (name: string) : expr option =\n";
  output_string oc "  List.assoc_opt name scope.vars\n";
  close_out oc

let () =
  generate_mli ();
  generate_ml ();
  print_endline "Generated ast.mli and ast.ml"
